#+TITLE: HSGy - 14
#+SUBTITLE: Lenses
#+DATE: October 29, 2021
#+STARTUP: beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation,aspectratio=169,8pt]
#+LATEX_HEADER: \usepackage{soul}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usemintedstyle{tango}
#+LATEX_HEADER: \setminted{mathescape=true}
#+LATEX_HEADER: \setbeamertemplate{itemize items}[circle]
#+LATEX_HEADER: \setbeamertemplate{enumerate items}[default]
#+LATEX_HEADER: \setbeamertemplate{caption}{\raggedright\insertcaption\par}
#+LATEX_HEADER: \setlength{\parskip}{\baselineskip}%
#+LATEX_HEADER: \setlength{\parindent}{0pt}%
#+LATEX_HEADER: \setbeamertemplate{navigation symbols}{}%remove navigation symbols
#+LATEX_HEADER: \newcommand{\hlyellow}[1]{\colorbox{yellow!50}{$\displaystyle#1$}}
#+LATEX_HEADER: \newcommand{\hlfancy}[2]{\sethlcolor{#1}\hl{#2}}
#+OPTIONS: H:1 toc:nil num:t
#+EXCLUDE_TAGS: noexport

#+begin_export latex
\newcommand{\mathcolorbox}[2]{%
  \begingroup
  \setlength{\fboxsep}{2pt}%
  \colorbox{#1}{$\displaystyle #2$}%
  \endgroup
}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}
#+end_export

* Haskell Study Group, yo!

Prerequisites:

1. You forgot Haskell syntax.
2. You are ready to suffer.

* Lenses

Lenses abstraction make the concept of a field of an abstraction, a first class
notion.

Lenses is a little language of its own.

Used by many interesting libraries.

* Data types

** Haskell                                                        :B_column:
:PROPERTIES:
:END:

#+begin_src haskell
  data Atom = Atom { _element :: String, _point :: Point }
  data Point = Point { _x :: Double, _y :: Double }
#+end_src

** Scala                                                          :B_column:
:PROPERTIES:
:END:

#+begin_src scala
  case class Atom(element: String, point: Point)
  case class Point(x: Double, y: Double)
#+end_src

* Getters

** Haskell                                                        :B_column:
:PROPERTIES:
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  getAtomX :: Atom -> Double
  getAtomX = _x . _point
#+end_src

** Scala                                                          :B_column:
:PROPERTIES:
:BEAMER_col:             0.5
:END:

#+begin_src scala
  def getAtomX(atom: Atom): Double =
    atom.point.x
#+end_src

* Setters

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  setPoint :: Point -> Atom -> Atom
  setPoint p a = a { _point = p }

  setElement :: String -> Atom -> Atom
  setElement e a = a { _element = e }

  setX:: Double -> Point -> Point
  setX x p = p { _x = x }

  setY:: Double -> Point -> Point
  setY y p = p { _y = y }
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src scala
  def setPoint(point: Point, atom: Atom): Atom =
    atom.copy(point = point)

  def setElement(element: String, atom: Atom): Atom =
    atom.copy(element = element)

  def setX(x: Double, point: Point): Point =
    point.copy(x = x)

  def setY(Y: Double, point: Point): Point =
    point.copy(y = y)
#+end_src

* But what if... nested?

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  setAtomX :: Double -> Atom -> Atom
  setAtomX x a = setPoint (setX x (_point a)) a
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src scala
  def setAtomX(x: Double, atom: Atom): Atom =
    setPoint(setX(x, atom.point), point)
#+end_src

* Well, that's

#+ATTR_LATEX: :height 7.5cm
[[file:images/hory-shet.png]]

* A simple lens

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  data Lens a b = Lens
    { view :: a -> b,
      set :: b -> a -> a
    }
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+BEAMER: \pause

#+begin_src haskell
  point :: Lens Atom Point
  point = Lens _point setPoint

  element :: Lens Atom String
  element = Lens _element setElement

  x :: Lens Point Double
  x = Lens _x setX

  y :: Lens Point Double
  y = Lens _y setY
#+end_src

* To use it

#+begin_example
  λ> :t view x
  view x :: Point -> Double

  λ> view x (Point 42.0 36.0)
  42.0

  λ> :t set x
  set x :: Double -> Point -> Point

  λ> set x 12.0 (Point 42.0 36.0)
  Point {_x = 12.0, _y = 36.0}
#+end_example

* Composition

#+begin_src haskell
  comp :: Lens a b -> Lens b c -> Lens a c
  comp l1 l2 = Lens
    (view l2 . view l1)
    (\c a -> set l1 (set l2 c (view l1 a)) a)
#+end_src

* To use it

#+begin_example
  λ> :t view (point `comp` x)
  view (point `comp` x) :: Atom -> Double

  λ> view (point `comp` x) (Atom "oxygen" (Point 42.0 36.0))
  42.0

  λ> :t set (point `comp` x)
  set (point `comp` x) :: Double -> Atom -> Atom

  λ> set (point `comp` x) 12.0 (Atom "oxygen" (Point 42.0 36.0))
  Atom {_element = "oxygen", _point = Point {_x = 12.0, _y = 36.0}}
#+end_example

* /Over/coming patterns

#+begin_src haskell
  over :: Lens a b -> (b -> b) -> (a -> a)
  over l f a = set l (f (view l a)) a
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  moveAtom :: Atom -> Atom
  moveAtom = over (point `comp` x) (+ 1)
#+end_src

* Composition

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  comp :: Lens a b -> Lens b c -> Lens a c
  comp l1 l2 = Lens
    (view l2 . view l1)
    (\c a -> set l1 (set l2 c (view l1 a)) a)
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  comp :: Lens a b -> Lens b c -> Lens a c
  comp l1 l2 = Lens
    (view l2 . view l1)
    (over l1 . set l2)
#+end_src

* Redundant access to Lens

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  over :: Lens a b -> (b -> b) -> (a -> a)
  over l f a = set l (f (view l a)) a
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  data Lens a b = Lens
    { view :: a -> b,
      set :: b -> a -> a,
      over :: (b -> b) -> (a -> a)
    }
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
  mkLens v s = Lens v s (\f a -> s (f (v a)) a)
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+BEAMER: \pause

#+begin_src haskell
  point :: Lens Atom Point
  point = mkLens _point setPoint

  element :: Lens Atom String
  element = mkLens _element setElement

  x :: Lens Point Double
  x = mkLens _x setX

  y :: Lens Point Double
  y = mkLens _y setY
#+end_src

* Composition

#+begin_src haskell
  comp :: Lens a b -> Lens b c -> Lens a c
  comp l1 l2 =
    Lens
      (view l2 . view l1)
      (over l1 . set l2)
      (over l1 . over l2)
#+end_src

* Redundant =set=

#+begin_src haskell
  data Lens a b = Lens
    { view :: a -> b,
      over :: (b -> b) -> (a -> a)
    }
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  set :: Lens a b -> b -> a -> a
  set l b = over l (const b)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
  mkLens v s = Lens v (\f a -> s (f (v a)) a)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  comp :: Lens a b -> Lens b c -> Lens a c
  comp l1 l2 =
    Lens
      (view l2 . view l1)
      (over l1 . over l2)
#+end_src

* What about IO?

#+begin_src haskell
  askX :: Atom -> IO Atom
  askX = over (point `comp` x) askUser
    where
      askUser :: Double -> IO Double
      askUser a = do
        putStrLn $ "Current position is " ++ show a ++ ". New Position?"
        read <$> getLine
#+end_src

#+BEAMER: \pause

#+begin_example
  • Couldn't match type ‘Atom’ with ‘IO Atom’
    Expected type: Atom -> IO Atom
      Actual type: Atom -> Atom
  • In the expression: over (point `comp` x) askUser

  ...

  • Couldn't match type ‘IO Double’ with ‘Double’
    Expected type: Double -> Double
      Actual type: Double -> IO Double
  • In the second argument of ‘over’, namely ‘askUser’
    In the expression: over (point `comp` x) askUser
    In an equation for ‘askX’:

  ...
#+end_example

* =overIO=

#+begin_src haskell
  data Lens a b = Lens
    { view :: a -> b,
      over :: (b -> b) -> (a -> a),
      overIO :: (b -> IO b) -> (a -> IO a)
    }
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
  mkLens v s = Lens v o oIO
    where
      o f a = s (f (v a)) a
      oIO f a = (\b' -> s b' a) <$> f (v a)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  comp :: Lens a b -> Lens b c -> Lens a c
  comp l1 l2 =
    Lens
      (view l2 . view l1)
      (over l1 . over l2)
      (overIO l1 . overIO l2)
#+end_src

* Works

#+begin_src haskell
  askX :: Atom -> IO Atom
  askX = overF (point `comp` x) askUser
    where
      askUser :: Double -> IO Double
      askUser a = do
        putStrLn $ "Current position is " ++ show a ++ ". New Position?"
        read <$> getLine
#+end_src

* But generalisation +is the root of all evil+

#+begin_src haskell
  data Lens a b = Lens
    { view :: a -> b,
      over :: (b -> b) -> (a -> a),
      overF :: forall t. Functor t => (b -> t b) -> (a -> t a)
    }

  mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
  mkLens v s = Lens v o oF
    where
      o f a = s (f (v a)) a
      oF f a = (`s` a) <$> f (v a)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  set :: Lens a b -> b -> a -> a
  set l b = over l (const b)

  setF :: Functor f => Lens a b -> f b -> a -> f a
  setF l b = overF l (const b)
#+end_src

* Getting over =over=

#+begin_src haskell
  over  ::                        (b ->   b) -> (a ->   a)
  overF :: forall t. Functor t => (b -> t b) -> (a -> t a)
#+end_src

#+BEAMER: \pause

So we need some isomoprhism between some =t a= and =a=.

* Identity Functor

#+begin_src haskell
  newtype I a = MkI a

  unI :: I a -> a
  unI (MkI a) = a

  instance Functor I where
    fmap f a = MkI (f (unI a))
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  over :: Lens a b -> (b -> b) -> (a -> a)
  over l f a = unI $ l f' a
    where
      f' b = MkI (f b)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  data Lens a b = Lens
    { view :: a -> b,
      overF :: forall t. Functor t => (b -> t b) -> (a -> t a)
    }
#+end_src

* Naughty =view=

#+begin_src haskell
  view  ::                                       a -> b
  overF :: forall t. Functor t => (b -> t b) -> (a -> t a)
#+end_src

#+BEAMER: \pause

1. turn =b= into =t a=
2. provide =b -> t b=

* Constant Functor

#+begin_src haskell
  newtype C b a = MkC b

  unC :: C b a -> b
  unC (MkC b) = b

  instance Functor (C b) where
    fmap _ (MkC b) = MkC b
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  overF :: Functor t => Lens a b -> (b -> t b) -> a -> t a
  MkC   :: b -> C b a
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  λ> :t \l -> overF l MkC
  \l -> overF l MkC :: Lens a b -> a -> C b a

  λ> :t \l -> unC . overF l MkC
  \l -> unC . overF l MkC :: Lens a c -> a -> c
#+end_src

* Waaat?

#+begin_src haskell
  view :: Lens a b -> a -> b
  view l a = unC $ overF l MkC a
#+end_src

* Waaaaat?

#+begin_src haskell
  type Lens a b = forall t. Functor t => (b -> t b) -> (a -> t a)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  set :: Lens a b -> b -> a -> a
  set l b = over l (const b)

  setF :: Functor f => Lens a b -> f b -> a -> f a
  setF l b = l (const b)

  over :: Lens a b -> (b -> b) -> (a -> a)
  over l f a = unI $ l (MkI . f) a

  view :: Lens a b -> a -> b
  view l a = unC $ l MkC a
#+end_src

* Waaaaaaat?

#+begin_src haskell
  type Lens a b = forall t. Functor t => (b -> t b) -> (a -> t a)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
  mkLens v s f a = (`s` a) <$> f (v a)
#+end_src

* Waaaaaaaaat?

#+begin_src haskell
  comp :: Lens a b -> Lens b c -> Lens a c
  comp l1 l2 = l1 . l2
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  setAtomX :: Double -> Atom -> Atom
  setAtomX = set (point . x)

  moveAtom :: Atom -> Atom
  moveAtom = over (point . x) (+ 1)
#+end_src

* Applicative behind the corner

#+begin_src haskell
  type Lens a b      = forall t. Functor t      => (b -> t b) -> (a -> t a)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  type Traversal a b = forall t . Applicative t => (b -> t b) -> (a -> t a)
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  lensToTraversal :: Lens a b -> Traversal a b
  lensToTraversal l = l
#+end_src

* Generalizing =over=

** code                                                          :B_columns:
:PROPERTIES:
:BEAMER_env:             columns
:END:

*** A                                                            :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  over :: Lens a b -> (b -> b) -> (a -> a)
  over l f a = unI $ l (MkI . f) a
#+end_src

*** B                                                            :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  over :: Traversal a b -> (b -> b) -> (a -> a)
  over l f a = unI $ l (MkI . f) a
#+end_src

** Helper                                                        :B_columns:
:PROPERTIES:
:BEAMER_env:             columns
:END:

#+BEAMER: \pause

*** A                                                            :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  instance Functor I where
    fmap f a = MkI (f (unI a))
#+end_src

*** B                                                            :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  instance Applicative I where
    pure a = MkI a
    f <*> a = MkI $ (unI f) (unI a)
#+end_src

* What about =view=?

#+begin_src haskell
  view :: Lens a b -> a -> b
  view l a = unC $ l MkC a

  newtype C b a = MkC b

  unC :: C b a -> b
  unC (MkC b) = bs

  instance Applicative (C b) where
    pure a = MkC undefined
    f <*> a = MkC undefined
#+end_src

* So...

- =Traversal a b= describes how one can (possibly effectful) set or update value
  of type =b= in =a=;
- =Lens a b= describes how one can (possibly effectful) set, update or *view*
  value of type =b= in =a=

* =Maybe= Traversal

#+begin_src haskell
  this :: Traversal (Maybe a) a
  this _ Nothing = pure Nothing
  this f (Just a) = Just <$> f a
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  this               :: Applicative t => (a -> t a) -> Maybe a -> t (Maybe a)
  this (\a -> [a,a]) :: Maybe a -> [Maybe a]

  λ> this (\a -> [a,a]) $ Just 1
  [Just 1,Just 1]

  λ> this (\a -> [a,a]) $ Nothing
  [Nothing]
#+end_src

* List Traversal

#+begin_src haskell
  elems :: Traversal [a] a
  elems _ [] = pure []
  elems f (a : as) = (:) <$> f a <*> elems f as
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  positiveOnly       :: Double -> Maybe Double
  elems              :: Applicative t => (a -> t a) -> [a] -> t [a]
  elems positiveOnly :: [Double] -> Maybe [Double]

  λ> elems positiveOnly [1.6, 4.2, 0, 3.13]
  Just [1.6,4.2,0.0,3.13]

  λ> elems positiveOnly [1.6, -1, 4.2, 0, 3.13]
  Nothing
#+end_src

* Pointy traversal

#+begin_src haskell
  points :: Traversal Point Double
  points f (Point a b) = Point <$> f a <*> f b
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  positiveOnly        :: Double -> Maybe Double
  points              :: Applicative t => (Double -> t Double) -> Point -> t Point
  points positiveOnly :: Point -> Maybe Point

  λ> points positiveOnly $ Point 1 2
  Just (Point {_x = 1.0, _y = 2.0})

  λ> points positiveOnly $ Point (-1) 2
  Nothing
#+end_src

* Getting all of them

So we cannot have view because the structure might have zero or more than one
elements. Well, then at least we should be able to get a list of them?

#+begin_src haskell
  listOf :: Traversal a b -> a -> [b]
#+end_src

#+BEAMER: \pause

Looks like =view=, just with list as a result.

* Constant

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  newtype C b a = MkC b

  unC :: C b a -> b
  unC (MkC b) = b

  instance Functor (C b) where
    fmap _ (MkC b) = MkC b

  instance Applicative (C b) where
    pure a = MkC undefined
    f <*> a = MkC undefined
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  newtype CL b a = MkCL [b]

  unCL :: CL b a -> [b]
  unCL (MkCL bs) = bs

  instance Functor (CL b) where
    fmap _ (MkCL bs) = MkCL bs

  instance Applicative (CL b) where
    pure _ = MkCL []
    f <*> a = MkCL (unCL f <> unCL a)
#+end_src

* Constant

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  newtype C b a = MkC b

  unC :: C b a -> b
  unC (MkC b) = b

  instance Functor (C b) where
    fmap _ (MkC b) = MkC b

  instance Monoid b => Applicative (C b) where
    pure a = MkC mempty
    f <*> a = MkC (unC f <> unC a)
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  newtype CL b a = MkCL [b]

  unCL :: CL b a -> [b]
  unCL (MkCL bs) = bs

  instance Functor (CL b) where
    fmap _ (MkCL bs) = MkCL bs

  instance Applicative (CL b) where
    pure _ = MkCL []
    f <*> a = MkCL (unCL f <> unCL a)
#+end_src

* =listOf=

#+begin_src haskell
  listOf :: Monoid b => Traversal a b -> a -> b
  listOf t a = unC $ t MkC a
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  listOf       :: Monoid b => Traversal a b -> a -> b
  listOf this  :: Monoid b => Maybe b -> b
  listOf elems :: Monoid b => [b] -> b

  λ> listOf this $ Just [1,2,3]
  [1,2,3]
  λ> listOf this $ Nothing
  []

  λ> listOf elems ["hello", " ", "HSGy 14"]
  "hello HSGy 14"
  λ> listOf elems []
  ""
#+end_src

* So...

- Lens is one position in a data structure (and precisely one, and one that is
  always there)
- Traversal describes many positions in a data structure

#+BEAMER: \pause

And they compose well:

#+begin_src haskell
  root
    .  el "books"
    ./ el "book"
    .  attributeIs "category" "Textbooks"
    ./ el "title"
    .  text
#+end_src

* References

- [[http://hackage.haskell.org/package/lens][lens library]]
- [[http://hackage.haskell.org/package/microlens][microlens library]]
- [[https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references][Lenses on WikiBooks]]
- [[https://artyom.me/lens-over-tea-1][Lens over Tea P1]]

* Thank you
