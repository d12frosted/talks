#+TITLE: HSGy - 14
#+SUBTITLE: Lenses
#+DATE: October 29, 2021
#+STARTUP: beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation,aspectratio=169,8pt]
#+LATEX_HEADER: \usepackage{soul}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usemintedstyle{tango}
#+LATEX_HEADER: \setminted{mathescape=true}
#+LATEX_HEADER: \setbeamertemplate{itemize items}[circle]
#+LATEX_HEADER: \setbeamertemplate{enumerate items}[default]
#+LATEX_HEADER: \setbeamertemplate{caption}{\raggedright\insertcaption\par}
#+LATEX_HEADER: \setlength{\parskip}{\baselineskip}%
#+LATEX_HEADER: \setlength{\parindent}{0pt}%
#+LATEX_HEADER: \setbeamertemplate{navigation symbols}{}%remove navigation symbols
#+LATEX_HEADER: \newcommand{\hlyellow}[1]{\colorbox{yellow!50}{$\displaystyle#1$}}
#+LATEX_HEADER: \newcommand{\hlfancy}[2]{\sethlcolor{#1}\hl{#2}}
#+OPTIONS: H:1 toc:nil num:t
#+EXCLUDE_TAGS: noexport

#+begin_export latex
\newcommand{\mathcolorbox}[2]{%
  \begingroup
  \setlength{\fboxsep}{2pt}%
  \colorbox{#1}{$\displaystyle #2$}%
  \endgroup
}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}
#+end_export

* Haskell Study Group, yo!

Prerequisites:

1. You forgot Haskell syntax.
2. You are ready to suffer.

* Lenses

Lenses abstraction make the concept of a field of an abstraction, a first class
notion.

Lenses is a little language of its own.

Used by many interesting libraries. Copycatted to Scala.

* Data types

** Haskell                                                        :B_column:
:PROPERTIES:
:END:

#+begin_src haskell
  data Atom = Atom { _element :: String, _point :: Point }
  data Point = Point { _x :: Double, _y :: Double }
#+end_src

** Scala                                                          :B_column:
:PROPERTIES:
:END:

#+begin_src scala
  case class Atom(element: String, point: Point)
  case class Point(x: Double, y: Double)
#+end_src

* Getters

** Haskell                                                        :B_column:
:PROPERTIES:
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  getAtomX :: Atom -> Double
  getAtomX = _x . _point
#+end_src

** Scala                                                          :B_column:
:PROPERTIES:
:BEAMER_col:             0.5
:END:

#+begin_src scala
  def getAtomX(atom: Atom): Double =
    atom.point.x
#+end_src

* Setters

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  setPoint :: Point -> Atom -> Atom
  setPoint p a = a { _point = p }

  setElement :: String -> Atom -> Atom
  setElement e a = a { _element = e }

  setX:: Double -> Point -> Point
  setX x p = p { _x = x }

  setY:: Double -> Point -> Point
  setY y p = p { _y = y }
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src scala
  def setPoint(point: Point, atom: Atom): Atom =
    atom.copy(point = point)

  def setElement(element: String, atom: Atom): Atom =
    atom.copy(element = element)

  def setX(x: Double, point: Point): Point =
    point.copy(x = x)

  def setY(Y: Double, point: Point): Point =
    point.copy(y = y)
#+end_src

* But what if... nested?

** A                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src haskell
  setAtomX :: Double -> Atom -> Atom
  setAtomX x a = setPoint (setX x (_point a)) a
#+end_src

** B                                                              :B_column:
:PROPERTIES:
:BEAMER_env:             column
:BEAMER_col:             0.5
:END:

#+begin_src scala
  def setAtomX(x: Double, atom: Atom): Atom =
    setPoint(setX(x, atom.point), point)
#+end_src

* Well, that's

#+ATTR_LATEX: :height 7.5cm
[[file:images/hory-shet.png]]

* A simple lens

#+begin_src haskell
  data Lens a b = { view :: a -> b
                  , set :: b -> a -> a
      }
#+end_src

#+BEAMER: \pause

#+begin_src haskell
  point :: Lens Atom Point
  point = Lens _point setPoint

  element :: Lens Atom String
  element = Lens _element setElement

  x :: Lens Point Double
  x = Lens _x setX

  y :: Lens Point Double
  y = Lens _y setY
#+end_src
