% Created 2021-10-29 Fri 09:34
% Intended LaTeX compiler: pdflatex
\documentclass[presentation,aspectratio=169,8pt]{beamer}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{color}
\usepackage[newfloat]{minted}
\usepackage{soul}
\usepackage{mathtools}
\usemintedstyle{tango}
\setminted{mathescape=true}
\setbeamertemplate{itemize items}[circle]
\setbeamertemplate{enumerate items}[default]
\setbeamertemplate{caption}{\raggedright\insertcaption\par}
\setlength{\parskip}{\baselineskip}%
\setlength{\parindent}{0pt}%
\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\newcommand{\hlyellow}[1]{\colorbox{yellow!50}{$\displaystyle#1$}}
\newcommand{\hlfancy}[2]{\sethlcolor{#1}\hl{#2}}
\usetheme{default}
\author{Boris Buliga}
\date{October 29, 2021}
\title{HSGy - 14}
\subtitle{Lenses}
\hypersetup{
 pdfauthor={Boris Buliga},
 pdftitle={HSGy - 14},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.0.50 (Org mode 9.4.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\newcommand{\mathcolorbox}[2]{%
  \begingroup
  \setlength{\fboxsep}{2pt}%
  \colorbox{#1}{$\displaystyle #2$}%
  \endgroup
}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\begin{frame}[label={sec:orgf1d0005}]{Haskell Study Group, yo!}
Prerequisites:

\begin{enumerate}
\item You forgot Haskell syntax.
\item You are ready to suffer.
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:org3d5ead0}]{Lenses}
Lenses abstraction make the concept of a field of an abstraction, a first class
notion.

Lenses is a little language of its own.

Used by many interesting libraries.
\end{frame}

\begin{frame}[label={sec:org1443c8e},fragile]{Data types}
 \begin{block}{Haskell}
\begin{minted}[]{haskell}
data Atom = Atom { _element :: String, _point :: Point }
data Point = Point { _x :: Double, _y :: Double }
\end{minted}
\end{block}

\begin{block}{Scala}
\begin{minted}[]{scala}
case class Atom(element: String, point: Point)
case class Point(x: Double, y: Double)
\end{minted}
\end{block}
\end{frame}

\begin{frame}[label={sec:org239f4d6},fragile]{Getters}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
getAtomX :: Atom -> Double
getAtomX = _x . _point
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{minted}[]{scala}
def getAtomX(atom: Atom): Double =
  atom.point.x
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org59462f4},fragile]{Setters}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
setPoint :: Point -> Atom -> Atom
setPoint p a = a { _point = p }

setElement :: String -> Atom -> Atom
setElement e a = a { _element = e }

setX:: Double -> Point -> Point
setX x p = p { _x = x }

setY:: Double -> Point -> Point
setY y p = p { _y = y }
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{minted}[]{scala}
def setPoint(point: Point, atom: Atom): Atom =
  atom.copy(point = point)

def setElement(element: String, atom: Atom): Atom =
  atom.copy(element = element)

def setX(x: Double, point: Point): Point =
  point.copy(x = x)

def setY(Y: Double, point: Point): Point =
  point.copy(y = y)
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orgbf87725},fragile]{But what if\ldots{} nested?}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
setAtomX :: Double -> Atom -> Atom
setAtomX x a = setPoint (setX x (_point a)) a
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{minted}[]{scala}
def setAtomX(x: Double, atom: Atom): Atom =
  setPoint(setX(x, atom.point), point)
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org62316a9}]{Well, that's}
\begin{center}
\includegraphics[height=7.5cm]{images/hory-shet.png}
\end{center}
\end{frame}

\begin{frame}[label={sec:orgccd9ffb},fragile]{A simple lens}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
data Lens a b = Lens
  { view :: a -> b,
    set :: b -> a -> a
  }
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\pause

\begin{minted}[]{haskell}
point :: Lens Atom Point
point = Lens _point setPoint

element :: Lens Atom String
element = Lens _element setElement

x :: Lens Point Double
x = Lens _x setX

y :: Lens Point Double
y = Lens _y setY
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orgadac9e2},fragile]{To use it}
 \begin{verbatim}
λ> :t view x
view x :: Point -> Double

λ> view x (Point 42.0 36.0)
42.0

λ> :t set x
set x :: Double -> Point -> Point

λ> set x 12.0 (Point 42.0 36.0)
Point {_x = 12.0, _y = 36.0}
\end{verbatim}
\end{frame}

\begin{frame}[label={sec:orgca9092a},fragile]{Composition}
 \begin{minted}[]{haskell}
comp :: Lens a b -> Lens b c -> Lens a c
comp l1 l2 = Lens
  (view l2 . view l1)
  (\c a -> set l1 (set l2 c (view l1 a)) a)
\end{minted}
\end{frame}

\begin{frame}[label={sec:org67e3a8f},fragile]{To use it}
 \begin{verbatim}
λ> :t view (point `comp` x)
view (point `comp` x) :: Atom -> Double

λ> view (point `comp` x) (Atom "oxygen" (Point 42.0 36.0))
42.0

λ> :t set (point `comp` x)
set (point `comp` x) :: Double -> Atom -> Atom

λ> set (point `comp` x) 12.0 (Atom "oxygen" (Point 42.0 36.0))
Atom {_element = "oxygen", _point = Point {_x = 12.0, _y = 36.0}}
\end{verbatim}
\end{frame}

\begin{frame}[label={sec:orgf5e7382},fragile]{/Over/coming patterns}
 \begin{minted}[]{haskell}
over :: Lens a b -> (b -> b) -> (a -> a)
over l f a = set l (f (view l a)) a
\end{minted}

\pause

\begin{minted}[]{haskell}
moveAtom :: Atom -> Atom
moveAtom = over (point `comp` x) (+ 1)
\end{minted}
\end{frame}

\begin{frame}[label={sec:org1fa2b7e},fragile]{Composition}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
comp :: Lens a b -> Lens b c -> Lens a c
comp l1 l2 = Lens
  (view l2 . view l1)
  (\c a -> set l1 (set l2 c (view l1 a)) a)
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
comp :: Lens a b -> Lens b c -> Lens a c
comp l1 l2 = Lens
  (view l2 . view l1)
  (over l1 . set l2)
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org77b305e},fragile]{Redundant access to Lens}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
over :: Lens a b -> (b -> b) -> (a -> a)
over l f a = set l (f (view l a)) a
\end{minted}

\pause

\begin{minted}[]{haskell}
data Lens a b = Lens
  { view :: a -> b,
    set :: b -> a -> a,
    over :: (b -> b) -> (a -> a)
  }
\end{minted}

\pause

\begin{minted}[]{haskell}
mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
mkLens v s = Lens v s (\f a -> s (f (v a)) a)
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\pause

\begin{minted}[]{haskell}
point :: Lens Atom Point
point = mkLens _point setPoint

element :: Lens Atom String
element = mkLens _element setElement

x :: Lens Point Double
x = mkLens _x setX

y :: Lens Point Double
y = mkLens _y setY
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orgacc5d90},fragile]{Composition}
 \begin{minted}[]{haskell}
comp :: Lens a b -> Lens b c -> Lens a c
comp l1 l2 =
  Lens
    (view l2 . view l1)
    (over l1 . set l2)
    (over l1 . over l2)
\end{minted}
\end{frame}

\begin{frame}[label={sec:orga75e9e7},fragile]{Redundant \texttt{set}}
 \begin{minted}[]{haskell}
data Lens a b = Lens
  { view :: a -> b,
    over :: (b -> b) -> (a -> a)
  }
\end{minted}

\pause

\begin{minted}[]{haskell}
set :: Lens a b -> b -> a -> a
set l b = over l (const b)
\end{minted}

\pause

\begin{minted}[]{haskell}
mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
mkLens v s = Lens v (\f a -> s (f (v a)) a)
\end{minted}

\pause

\begin{minted}[]{haskell}
comp :: Lens a b -> Lens b c -> Lens a c
comp l1 l2 =
  Lens
    (view l2 . view l1)
    (over l1 . over l2)
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgc2ac0ff},fragile]{What about IO?}
 \begin{minted}[]{haskell}
askX :: Atom -> IO Atom
askX = over (point `comp` x) askUser
  where
    askUser :: Double -> IO Double
    askUser a = do
      putStrLn $ "Current position is " ++ show a ++ ". New Position?"
      read <$> getLine
\end{minted}

\pause

\begin{verbatim}
• Couldn't match type ‘Atom’ with ‘IO Atom’
  Expected type: Atom -> IO Atom
    Actual type: Atom -> Atom
• In the expression: over (point `comp` x) askUser

...

• Couldn't match type ‘IO Double’ with ‘Double’
  Expected type: Double -> Double
    Actual type: Double -> IO Double
• In the second argument of ‘over’, namely ‘askUser’
  In the expression: over (point `comp` x) askUser
  In an equation for ‘askX’:

...
\end{verbatim}
\end{frame}

\begin{frame}[label={sec:org812ce49},fragile]{\texttt{overIO}}
 \begin{minted}[]{haskell}
data Lens a b = Lens
  { view :: a -> b,
    over :: (b -> b) -> (a -> a),
    overIO :: (b -> IO b) -> (a -> IO a)
  }
\end{minted}

\pause

\begin{minted}[]{haskell}
mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
mkLens v s = Lens v o oIO
  where
    o f a = s (f (v a)) a
    oIO f a = (\b' -> s b' a) <$> f (v a)
\end{minted}

\pause

\begin{minted}[]{haskell}
comp :: Lens a b -> Lens b c -> Lens a c
comp l1 l2 =
  Lens
    (view l2 . view l1)
    (over l1 . over l2)
    (overIO l1 . overIO l2)
\end{minted}
\end{frame}

\begin{frame}[label={sec:org85f7069},fragile]{Works}
 \begin{minted}[]{haskell}
askX :: Atom -> IO Atom
askX = overF (point `comp` x) askUser
  where
    askUser :: Double -> IO Double
    askUser a = do
      putStrLn $ "Current position is " ++ show a ++ ". New Position?"
      read <$> getLine
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgcd475dc},fragile]{But generalisation \sout{is the root of all evil}}
 \begin{minted}[]{haskell}
data Lens a b = Lens
  { view :: a -> b,
    over :: (b -> b) -> (a -> a),
    overF :: forall t. Functor t => (b -> t b) -> (a -> t a)
  }

mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
mkLens v s = Lens v o oF
  where
    o f a = s (f (v a)) a
    oF f a = (`s` a) <$> f (v a)
\end{minted}

\pause

\begin{minted}[]{haskell}
set :: Lens a b -> b -> a -> a
set l b = over l (const b)

setF :: Functor f => Lens a b -> f b -> a -> f a
setF l b = overF l (const b)
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgd65d1a2},fragile]{Getting over \texttt{over}}
 \begin{minted}[]{haskell}
over  ::                        (b ->   b) -> (a ->   a)
overF :: forall t. Functor t => (b -> t b) -> (a -> t a)
\end{minted}

\pause

So we need some isomoprhism between some \texttt{t a} and \texttt{a}.
\end{frame}

\begin{frame}[label={sec:orgb508df8},fragile]{Identity Functor}
 \begin{minted}[]{haskell}
newtype I a = MkI a

unI :: I a -> a
unI (MkI a) = a

instance Functor I where
  fmap f a = MkI (f (unI a))
\end{minted}

\pause

\begin{minted}[]{haskell}
over :: Lens a b -> (b -> b) -> (a -> a)
over l f a = unI $ l f' a
  where
    f' b = MkI (f b)
\end{minted}

\pause

\begin{minted}[]{haskell}
data Lens a b = Lens
  { view :: a -> b,
    overF :: forall t. Functor t => (b -> t b) -> (a -> t a)
  }
\end{minted}
\end{frame}

\begin{frame}[label={sec:org7e11063},fragile]{Naughty \texttt{view}}
 \begin{minted}[]{haskell}
view  ::                                       a -> b
overF :: forall t. Functor t => (b -> t b) -> (a -> t a)
\end{minted}

\pause

\begin{enumerate}
\item turn \texttt{b} into \texttt{t a}
\item provide \texttt{b -> t b}
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:org6f9650c},fragile]{Constant Functor}
 \begin{minted}[]{haskell}
newtype C b a = MkC b

unC :: C b a -> b
unC (MkC b) = b

instance Functor (C b) where
  fmap _ (MkC b) = MkC b
\end{minted}

\pause

\begin{minted}[]{haskell}
overF :: Functor t => Lens a b -> (b -> t b) -> a -> t a
MkC   :: b -> C b a
\end{minted}

\pause

\begin{minted}[]{haskell}
λ> :t \l -> overF l MkC
\l -> overF l MkC :: Lens a b -> a -> C b a

λ> :t \l -> unC . overF l MkC
\l -> unC . overF l MkC :: Lens a c -> a -> c
\end{minted}
\end{frame}

\begin{frame}[label={sec:org02dc198},fragile]{Waaat?}
 \begin{minted}[]{haskell}
view :: Lens a b -> a -> b
view l a = unC $ overF l MkC a
\end{minted}
\end{frame}

\begin{frame}[label={sec:org46eae7e},fragile]{Waaaaat?}
 \begin{minted}[]{haskell}
type Lens a b = forall t. Functor t => (b -> t b) -> (a -> t a)
\end{minted}

\pause

\begin{minted}[]{haskell}
set :: Lens a b -> b -> a -> a
set l b = over l (const b)

setF :: Functor f => Lens a b -> f b -> a -> f a
setF l b = l (const b)

over :: Lens a b -> (b -> b) -> (a -> a)
over l f a = unI $ l (MkI . f) a

view :: Lens a b -> a -> b
view l a = unC $ l MkC a
\end{minted}
\end{frame}

\begin{frame}[label={sec:orga0dd936},fragile]{Waaaaaaat?}
 \begin{minted}[]{haskell}
type Lens a b = forall t. Functor t => (b -> t b) -> (a -> t a)
\end{minted}

\pause

\begin{minted}[]{haskell}
mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
mkLens v s f a = (`s` a) <$> f (v a)
\end{minted}
\end{frame}

\begin{frame}[label={sec:org11ab74c},fragile]{Waaaaaaaaat?}
 \begin{minted}[]{haskell}
comp :: Lens a b -> Lens b c -> Lens a c
comp l1 l2 = l1 . l2
\end{minted}

\pause

\begin{minted}[]{haskell}
setAtomX :: Double -> Atom -> Atom
setAtomX = set (point . x)

moveAtom :: Atom -> Atom
moveAtom = over (point . x) (+ 1)
\end{minted}
\end{frame}

\begin{frame}[label={sec:org9a5c21b},fragile]{Applicative behind the corner}
 \begin{minted}[]{haskell}
type Lens a b      = forall t. Functor t      => (b -> t b) -> (a -> t a)
\end{minted}

\pause

\begin{minted}[]{haskell}
type Traversal a b = forall t . Applicative t => (b -> t b) -> (a -> t a)
\end{minted}

\pause

\begin{minted}[]{haskell}
lensToTraversal :: Lens a b -> Traversal a b
lensToTraversal l = l
\end{minted}
\end{frame}

\begin{frame}[label={sec:org1b56eef},fragile]{Generalizing \texttt{over}}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
over :: Lens a b -> (b -> b) -> (a -> a)
over l f a = unI $ l (MkI . f) a
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
over :: Traversal a b -> (b -> b) -> (a -> a)
over l f a = unI $ l (MkI . f) a
\end{minted}
\end{column}
\end{columns}

\begin{columns}
\pause

\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
instance Functor I where
  fmap f a = MkI (f (unI a))
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
instance Applicative I where
  pure a = MkI a
  f <*> a = MkI $ (unI f) (unI a)
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orgcaa3ba6},fragile]{What about \texttt{view}?}
 \begin{minted}[]{haskell}
view :: Lens a b -> a -> b
view l a = unC $ l MkC a

newtype C b a = MkC b

unC :: C b a -> b
unC (MkC b) = bs

instance Applicative (C b) where
  pure a = MkC undefined
  f <*> a = MkC undefined
\end{minted}
\end{frame}

\begin{frame}[label={sec:org50fc93f},fragile]{So\ldots{}}
 \begin{itemize}
\item \texttt{Traversal a b} describes how one can (possibly effectful) set or update value
of type \texttt{b} in \texttt{a};
\item \texttt{Lens a b} describes how one can (possibly effectful) set, update or \alert{view}
value of type \texttt{b} in \texttt{a}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org09f31f3},fragile]{\texttt{Maybe} Traversal}
 \begin{minted}[]{haskell}
this :: Traversal (Maybe a) a
this _ Nothing = pure Nothing
this f (Just a) = Just <$> f a
\end{minted}

\pause

\begin{minted}[]{haskell}
this               :: Applicative t => (a -> t a) -> Maybe a -> t (Maybe a)
this (\a -> [a,a]) :: Maybe a -> [Maybe a]

λ> this (\a -> [a,a]) $ Just 1
[Just 1,Just 1]

λ> this (\a -> [a,a]) $ Nothing
[Nothing]
\end{minted}
\end{frame}

\begin{frame}[label={sec:org5b786c6},fragile]{List Traversal}
 \begin{minted}[]{haskell}
elems :: Traversal [a] a
elems _ [] = pure []
elems f (a : as) = (:) <$> f a <*> elems f as
\end{minted}

\pause

\begin{minted}[]{haskell}
positiveOnly       :: Double -> Maybe Double
elems              :: Applicative t => (a -> t a) -> [a] -> t [a]
elems positiveOnly :: [Double] -> Maybe [Double]

λ> elems positiveOnly [1.6, 4.2, 0, 3.13]
Just [1.6,4.2,0.0,3.13]

λ> elems positiveOnly [1.6, -1, 4.2, 0, 3.13]
Nothing
\end{minted}
\end{frame}

\begin{frame}[label={sec:org11071cb},fragile]{Pointy traversal}
 \begin{minted}[]{haskell}
points :: Traversal Point Double
points f (Point a b) = Point <$> f a <*> f b
\end{minted}

\pause

\begin{minted}[]{haskell}
positiveOnly        :: Double -> Maybe Double
points              :: Applicative t => (Double -> t Double) -> Point -> t Point
points positiveOnly :: Point -> Maybe Point

λ> points positiveOnly $ Point 1 2
Just (Point {_x = 1.0, _y = 2.0})

λ> points positiveOnly $ Point (-1) 2
Nothing
\end{minted}
\end{frame}

\begin{frame}[label={sec:org5b811b8},fragile]{Getting all of them}
 So we cannot have view because the structure might have zero or more than one
elements. Well, then at least we should be able to get a list of them?

\begin{minted}[]{haskell}
listOf :: Traversal a b -> a -> [b]
\end{minted}

\pause

Looks like \texttt{view}, just with list as a result.
\end{frame}

\begin{frame}[label={sec:orgfc27415},fragile]{Constant}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
newtype C b a = MkC b

unC :: C b a -> b
unC (MkC b) = b

instance Functor (C b) where
  fmap _ (MkC b) = MkC b

instance Applicative (C b) where
  pure a = MkC undefined
  f <*> a = MkC undefined
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
newtype CL b a = MkCL [b]

unCL :: CL b a -> [b]
unCL (MkCL bs) = bs

instance Functor (CL b) where
  fmap _ (MkCL bs) = MkCL bs

instance Applicative (CL b) where
  pure _ = MkCL []
  f <*> a = MkCL (unCL f <> unCL a)
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org028c435},fragile]{Constant}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
newtype C b a = MkC b

unC :: C b a -> b
unC (MkC b) = b

instance Functor (C b) where
  fmap _ (MkC b) = MkC b

instance Monoid b => Applicative (C b) where
  pure a = MkC mempty
  f <*> a = MkC (unC f <> unC a)
\end{minted}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{minted}[]{haskell}
newtype CL b a = MkCL [b]

unCL :: CL b a -> [b]
unCL (MkCL bs) = bs

instance Functor (CL b) where
  fmap _ (MkCL bs) = MkCL bs

instance Applicative (CL b) where
  pure _ = MkCL []
  f <*> a = MkCL (unCL f <> unCL a)
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org597dd8e},fragile]{\texttt{listOf}}
 \begin{minted}[]{haskell}
listOf :: Monoid b => Traversal a b -> a -> b
listOf t a = unC $ t MkC a
\end{minted}

\pause

\begin{minted}[]{haskell}
listOf       :: Monoid b => Traversal a b -> a -> b
listOf this  :: Monoid b => Maybe b -> b
listOf elems :: Monoid b => [b] -> b

λ> listOf this $ Just [1,2,3]
[1,2,3]
λ> listOf this $ Nothing
[]

λ> listOf elems ["hello", " ", "HSGy 14"]
"hello HSGy 14"
λ> listOf elems []
""
\end{minted}
\end{frame}

\begin{frame}[label={sec:org0f98314},fragile]{So\ldots{}}
 \begin{itemize}
\item Lens is one position in a data structure (and precisely one, and one that is
always there)
\item Traversal describes many positions in a data structure
\end{itemize}

\pause

And they compose well:

\begin{minted}[]{haskell}
root
  .  el "books"
  ./ el "book"
  .  attributeIs "category" "Textbooks"
  ./ el "title"
  .  text
\end{minted}
\end{frame}

\begin{frame}[label={sec:org066036c}]{References}
\begin{itemize}
\item \url{http://hackage.haskell.org/package/lens}
\item \url{http://hackage.haskell.org/package/microlens}
\item \url{https://en.wikibooks.org/wiki/Haskell/Lenses\_and\_functional\_references}
\item \url{https://artyom.me/lens-over-tea-1}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgfbcde30}]{Thank you}
\end{frame}
\end{document}
